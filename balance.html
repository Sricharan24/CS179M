<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balance</title>
    <link rel="stylesheet" href="style.css">
    <script>

        let filename = "ShipCase";

        class PriorityQueue {
            constructor() {
                this.elements = [];
            }

            enqueue(priority, item) {
                this.elements.push({ priority, item });
                this.elements.sort((a, b) => a.priority - b.priority);
            }

            dequeue() {
                return this.elements.shift().item;
            }

            isEmpty() {
                return this.elements.length === 0;
            }
        }

        let balancedGrid = null; 

        function appendToLog(event) {
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace("T", " ");
            const existingLog = localStorage.getItem("logFileContent") || "";
            const updatedLog = `${existingLog}${timestamp} - ${event}\n`;

            localStorage.setItem("logFileContent", updatedLog);
            console.log(`${timestamp} - ${event}`); 
        }

        async function parseManifestFile(filePath) {
            const response = await fetch(filePath);
            const text = await response.text();
            const rows = text.split("\n").filter(line => line.trim() !== "");
            const grid = Array(8).fill(null).map(() => Array(12).fill(null));

            rows.forEach(row => {
                const match = row.match(/\[(\d+),(\d+)\],\s?\{(\d+)\},\s?([\w\s]+)/);
                if (match) {
                    const [_, x, y, weight, status] = match;
                    const rowIdx = parseInt(x, 10) - 1;
                    const colIdx = parseInt(y, 10) - 1;
                    grid[rowIdx][colIdx] = { weight: parseInt(weight, 10), status };
                }
            });

            return grid;
        }

        function generateManifest(grid) {
            let manifest = "";
            grid.forEach((row, rowIdx) => {
                row.forEach((cell, colIdx) => {
                    if (cell) {
                        manifest += `[${rowIdx + 1},${colIdx + 1}], {${cell.weight}}, ${cell.status}\n`;
                    } else {
                        manifest += `[${rowIdx + 1},${colIdx + 1}], {00000}, UNUSED\n`;
                    }
                });
            });
            return manifest;
        }

        function downloadManifest(grid) {
            const manifestContent = generateManifest(grid);
            const blob = new Blob([manifestContent], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = "UpdatedManifest.txt";
            link.click();
        }

        function calculateWeight(grid, startCol, endCol) {
            let weight = 0;
            for (let row = 0; row < grid.length; row++) {
                for (let col = startCol; col < endCol; col++) {
                    if (grid[row][col] && grid[row][col].status !== "UNUSED" && grid[row][col].status !== "NAN") {
                        weight += grid[row][col].weight;
                    }
                }
            }
            return weight;
        }

        function isBalanced(leftWeight, rightWeight) {
            const totalWeight = leftWeight + rightWeight;
            const imbalance = Math.abs(leftWeight - rightWeight) / totalWeight;
            return imbalance <= 0.1;
        }

        function aStarBalancing(grid) {
            const cols = grid[0].length;
            const leftCols = Math.floor(cols / 2);

            let leftWeight = calculateWeight(grid, 0, leftCols);
            let rightWeight = calculateWeight(grid, leftCols, cols);

            const startState = { grid, leftWeight, rightWeight, moves: [] };
            const pq = new PriorityQueue();
            pq.enqueue(Math.abs(leftWeight - rightWeight), startState);

            const visited = new Set();

            while (!pq.isEmpty()) {
                const currentState = pq.dequeue();
                const { grid: currentGrid, leftWeight, rightWeight, moves } = currentState;

                if (isBalanced(leftWeight, rightWeight)) {
                    return { grid: currentGrid, moves };
                }

                const stateKey = JSON.stringify(currentGrid);
                if (visited.has(stateKey)) continue;
                visited.add(stateKey);

                for (let row = 0; row < grid.length; row++) {
                    for (let col = 0; col < grid[0].length; col++) {
                        if (currentGrid[row][col] && currentGrid[row][col].status !== "UNUSED" && currentGrid[row][col].status !== "NAN") {
                            for (let targetCol = 0; targetCol < grid[0].length; targetCol++) {
                                if (!currentGrid[row][targetCol] || currentGrid[row][targetCol].status === "UNUSED") {
                                    const newGrid = currentGrid.map(r => r.map(c => (c ? { ...c } : null)));
                                    newGrid[row][targetCol] = { ...newGrid[row][col] };
                                    newGrid[row][col] = null;

                                    const newLeftWeight = calculateWeight(newGrid, 0, leftCols);
                                    const newRightWeight = calculateWeight(newGrid, leftCols, cols);

                                    const newMoves = [...moves, { from: [row + 1, col + 1], to: [row + 1, targetCol + 1] }];
                                    pq.enqueue(
                                        Math.abs(newLeftWeight - newRightWeight) + newMoves.length,
                                        { grid: newGrid, leftWeight: newLeftWeight, rightWeight: newRightWeight, moves: newMoves }
                                    );
                                }
                            }
                        }
                    }
                }
            }

            return null;
        }

        function displayMove(from, to) {
            const movesList = document.getElementById("movesList");
            const moveItem = document.createElement("li");
            moveItem.textContent = `Move box from (${from[0]}, ${from[1]}) to (${to[0]}, ${to[1]})`;
            movesList.innerHTML = ""; 
            movesList.appendChild(moveItem);
        }

        async function balanceManifest() {
            const manifestPath = "./data/ShipCase.txt";
            const grid = await parseManifestFile(manifestPath);

            const result = aStarBalancing(grid);

            const movesList = document.getElementById("movesList");
            movesList.innerHTML = ""; 

            if (result) {
                const finalMove = result.moves[result.moves.length - 1];
                if (finalMove) {
                    appendToLog(`Moved box from [${finalMove.from[0]}, ${finalMove.from[1]}] to [${finalMove.to[0]}, ${finalMove.to[1]}]`);
                    displayMove(finalMove.from, finalMove.to);
                }

                balancedGrid = result.grid;
                alert(`Balancing completed in ${result.moves.length} moves.`);

                const downloadButton = document.getElementById("downloadButton");
                downloadButton.style.display = "inline-block";
            } else {
                alert("No solution found to balance the manifest.");
            }
        }

        function triggerManifestDownload() {
    if (!balancedGrid) {
        alert("Please run the balancing process first.");
        return;
    }

    const manifestContent = generateManifest(balancedGrid); // Use balancedGrid for the updated manifest
    const downloadName = `${filename}OUTBOUND.txt`;

    const blob = new Blob([manifestContent], { type: "text/plain" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = downloadName;
    link.click();
}

    </script>
</head>
<body>
    <div class="centered-container">
        <h1>Balance</h1>
        <button onclick="balanceManifest()">Run Balancing</button>
        <button id="downloadButton" onclick="triggerManifestDownload()" class="manifest-button" style="display: none;">Download Manifest</button>
        <div id="movesContainer">
            <h2>Moves:</h2>
            <ol id="movesList"></ol>
        </div>
    </div>
</body>
</html>