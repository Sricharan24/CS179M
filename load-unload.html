<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load/Unload</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Load/Unload</h1>
        <div class="input-container">
            <label for="offload">Container to Offload:</label>
            <input id="offload" type="text" placeholder="e.g., Cat">
        </div>
        <div class="input-container">
            <label for="load">Container to Load:</label>
            <input id="load" type="text" placeholder="e.g., NewContainer">
        </div>
        <div class="button-container">
            <button class="button" onclick="handleTransfers()">Execute</button>
        </div>
        <div id="result" style="margin-top: 20px;"></div>
    </div>

    <script>
        let grid = null; // Global grid variable

        // Parse the manifest into a grid representation
        function parseManifestToGrid(text) {
            const lines = text.trim().split("\n");
            const grid = Array.from({ length: 8 }, () =>
                Array.from({ length: 12 }, () => ({ id: "00000", weight: 0, name: "UNUSED" }))
            );

            lines.forEach(line => {
                const [coordinates, weight, name] = line.split(", ").map(item => item.trim());
                const [row, col] = coordinates.replace("[", "").replace("]", "").split(",").map(Number);
                grid[row - 1][col - 1] = {
                    id: weight.replace("{", "").replace("}", ""),
                    weight: parseFloat(weight.replace("{", "").replace("}", "")) || 0,
                    name: name,
                };
            });

            return grid;
        }

        // Find the position of a container by name
        function findContainer(grid, containerName) {
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[0].length; c++) {
                    if (grid[r][c].name === containerName) {
                        return [r, c];
                    }
                }
            }
            return [-1, -1];
        }

        // Check if a position is within grid bounds
        function isWithinBounds(row, col, grid) {
            return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;
        }

        // A* search algorithm to find the closest unused slot
        function aStarFindSlot(grid, start) {
            const directions = [
                [0, 1],  // right
                [0, -1], // left
                [1, 0],  // down
                [-1, 0], // up
            ];

            const openSet = [{ position: start, cost: 0 }]; // Priority queue
            const visited = new Set();

            while (openSet.length > 0) {
                // Sort by cost (lowest first) and take the first node
                openSet.sort((a, b) => a.cost - b.cost);
                const current = openSet.shift();
                const [currentRow, currentCol] = current.position;

                // If this slot is unused, return it
                if (grid[currentRow][currentCol].name === "UNUSED") {
                    return [currentRow, currentCol];
                }

                const currentKey = `${currentRow},${currentCol}`;
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                // Explore neighbors
                for (const [dr, dc] of directions) {
                    const neighborRow = currentRow + dr;
                    const neighborCol = currentCol + dc;

                    if (isWithinBounds(neighborRow, neighborCol, grid) && !visited.has(`${neighborRow},${neighborCol}`)) {
                        const newCost = current.cost + 1; // Increment cost for each step
                        openSet.push({ position: [neighborRow, neighborCol], cost: newCost });
                    }
                }
            }

            return [-1, -1]; // No slot found
        }

        // Display the updated manifest in the UI
        function displayUpdatedManifest(grid) {
            const resultDiv = document.getElementById("result");
            const formattedManifest = grid.map((row, rowIndex) =>
                row.map((cell, colIndex) => {
                    const coordinates = `[${rowIndex + 1},${colIndex + 1}]`;
                    return `${coordinates}: ${cell.name} (${cell.id})`;
                }).join("\n")
            ).join("\n\n");

            resultDiv.innerHTML = `
                <h3>Updated Manifest:</h3>
                <pre>${formattedManifest}</pre>
            `;

            localStorage.setItem("currentGrid", JSON.stringify(grid)); // Save the updated grid
        }

        // Handle offloading of a container
        async function handleOffload(grid, containerName) {
            const position = findContainer(grid, containerName);
            if (position[0] === -1) {
                alert(`Container "${containerName}" not found.`);
                return;
            }

            console.log(`Offloading ${containerName} from ${position}`);
            grid[position[0]][position[1]] = { id: "00000", weight: 0, name: "UNUSED" };
        }

        // Handle loading of a container
        async function handleLoad(grid, containerName) {
            const startPosition = [0, 0]; // Starting position (top-left corner)
            const availableSlot = aStarFindSlot(grid, startPosition);

            if (availableSlot[0] === -1) {
                alert("No empty slot available for loading.");
                return;
            }

            const [targetRow, targetCol] = availableSlot;

            grid[targetRow][targetCol] = {
                id: Math.floor(Math.random() * 100000).toString().padStart(5, "0"),
                weight: Math.random() * 100,
                name: containerName,
            };

            console.log(`Loaded "${containerName}" into position [${targetRow + 1},${targetCol + 1}].`);
        }

        // Handle load and offload operations
        async function handleTransfers() {
            const offload = document.getElementById("offload").value.trim();
            const load = document.getElementById("load").value.trim();

            if (!grid) {
                const savedGrid = localStorage.getItem("currentGrid");
                grid = savedGrid ? JSON.parse(savedGrid) : grid;
            }

            if (offload) {
                await handleOffload(grid, offload);
            }

            if (load) {
                await handleLoad(grid, load);
            }

            displayUpdatedManifest(grid);
        }

        // Load the manifest on page load (original manifest on refresh)
        window.addEventListener("load", async () => {
            const response = await fetch("data/ShipCase.txt");
            const manifestText = await response.text();
            grid = parseManifestToGrid(manifestText);
            displayUpdatedManifest(grid); // Display original manifest
        });
    </script>
</body>
</html>
