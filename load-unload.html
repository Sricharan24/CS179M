<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load/Unload</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>Load/Unload</h1>
        <div class="input-container">
            <label for="offload">Container to Offload:</label>
            <input id="offload" type="text" placeholder="e.g., Cat">
        </div>
        <div class="input-container">
            <label for="load">Container to Load:</label>
            <input id="load" type="text" placeholder="e.g., NewContainer">
        </div>
        <div class="button-container">
            <button class="button" onclick="handleTransfers()">Execute</button>
        </div>
        <div id="result" style="margin-top: 20px;"></div>
        <button id="downloadManifestButton" onclick="triggerManifestDownload()" class="manifest-button">Download Manifest</button>
    </div>

    <script>
        let grid = null; 

        function appendToLog(event) {
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace("T", " ");
            const existingLog = localStorage.getItem("logFileContent") || "";
            const updatedLog = `${existingLog}${timestamp} - ${event}\n`;

            localStorage.setItem("logFileContent", updatedLog);
            console.log(`${timestamp} - ${event}`);
        }

        function parseManifestToGrid(text) {
            const lines = text.trim().split("\n");
            const grid = Array.from({ length: 8 }, () =>
                Array.from({ length: 12 }, () => ({ weight: 0, name: "UNUSED" }))
            );

            lines.forEach(line => {
                const [coordinates, weight, name] = line.split(", ").map(item => item.trim());
                const [row, col] = coordinates.replace("[", "").replace("]", "").split(",").map(Number);
                grid[row - 1][col - 1] = {
                    weight: parseFloat(weight.replace("{", "").replace("}", "")) || 0,
                    name: name,
                };
            });

            return grid;
        }

        function generateManifest(grid) {
            return grid
                .map((row, rowIndex) =>
                    row
                        .map(
                            (cell, colIndex) =>
                                `[${rowIndex + 1},${colIndex + 1}], {${cell.weight}}, ${cell.name}`
                        )
                        .join("\n")
                )
                .join("\n");
        }

        function displayUpdatedManifest(grid) {
            const resultDiv = document.getElementById("result");
            const formattedManifest = generateManifest(grid);

            resultDiv.innerHTML = `
                <h3>Updated Manifest:</h3>
                <pre>${formattedManifest}</pre>
            `;

            localStorage.setItem("currentGrid", JSON.stringify(grid)); // Save the updated grid
        }

        async function handleOffload(grid, containerName) {
            const position = findContainer(grid, containerName);
            if (position[0] === -1) {
                alert(`Container "${containerName}" not found.`);
                return;
            }

            grid[position[0]][position[1]] = { weight: 0, name: "UNUSED" };

            appendToLog(`Offloaded container "${containerName}" from position [${position[0] + 1}, ${position[1] + 1}]`);
        }

        async function handleLoad(grid, containerName) {
            const startPosition = [0, 0];
            const availableSlot = aStarFindSlot(grid, startPosition);

            if (availableSlot[0] === -1) {
                alert("No empty slot available for loading.");
                return;
            }

            const [targetRow, targetCol] = availableSlot;
            const weight = Math.floor(Math.random() * 151) + 50;

            grid[targetRow][targetCol] = { weight, name: containerName };

            appendToLog(`Loaded container "${containerName}" (weight: ${weight}) into position [${targetRow + 1}, ${targetCol + 1}]`);
        }

        async function handleTransfers() {
            const offload = document.getElementById("offload").value.trim();
            const load = document.getElementById("load").value.trim();

            if (!grid) {
                const savedGrid = localStorage.getItem("currentGrid");
                grid = savedGrid ? JSON.parse(savedGrid) : grid;
            }

            if (offload) {
                await handleOffload(grid, offload);
            }

            if (load) {
                await handleLoad(grid, load);
            }

            displayUpdatedManifest(grid);
        }

        function triggerManifestDownload() {
            const manifestContent = generateManifest(grid);
            const baseName = localStorage.getItem("manifestName")?.split('.')[0] || "DefaultManifest";
            const downloadName = `${baseName}_OUTBOUND.txt`;

            const blob = new Blob([manifestContent], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = downloadName;
            link.click();
        }

        window.addEventListener("load", async () => {
            const response = await fetch("data/ShipCase.txt");
            const manifestText = await response.text();
            grid = parseManifestToGrid(manifestText);
            displayUpdatedManifest(grid);
        });

        function findContainer(grid, containerName) {
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[0].length; c++) {
                    if (grid[r][c].name === containerName) {
                        return [r, c];
                    }
                }
            }
            return [-1, -1];
        }

        function isWithinBounds(row, col, grid) {
            return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;
        }

        function aStarFindSlot(grid, start) {
            const directions = [
                [0, 1],  // right
                [0, -1], // left
                [1, 0],  // down
                [-1, 0], // up
            ];

            const openSet = [{ position: start, cost: 0 }];
            const visited = new Set();

            while (openSet.length > 0) {
                openSet.sort((a, b) => a.cost - b.cost);
                const current = openSet.shift();
                const [currentRow, currentCol] = current.position;

                const currentKey = `${currentRow},${currentCol}`;
                if (visited.has(currentKey)) continue;
                visited.add(currentKey);

                if (isValidLoadingSlot(grid, currentRow, currentCol)) {
                    return [currentRow, currentCol];
                }

                for (const [dr, dc] of directions) {
                    const neighborRow = currentRow + dr;
                    const neighborCol = currentCol + dc;

                    if (
                        isWithinBounds(neighborRow, neighborCol, grid) &&
                        !visited.has(`${neighborRow},${neighborCol}`)
                    ) {
                        openSet.push({
                            position: [neighborRow, neighborCol],
                            cost: current.cost + 1,
                        });
                    }
                }
            }

            return [-1, -1];
        }

        function isValidLoadingSlot(grid, row, col) {
            if (grid[row][col].name !== "UNUSED") return false;
            if (row === 0) return true;
            return grid[row - 1][col].name !== "UNUSED";
        }
    </script>
</body>
</html>
