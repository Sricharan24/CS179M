<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Load/Unload</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <style>
        .grid-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* Align the grid to the top */
        }
    
        .container {
            flex: 1;
        }
    
        .animation-grid {
            display: grid;
            grid-template-rows: repeat(8, 40px);
            grid-template-columns: repeat(12, 40px);
            gap: 5px;
            margin-left: 20px;
            margin-top: 0; /* Move the grid to the top */
        }
    
        .grid-cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            border: 1px solid #ccc;
            text-align: center;
            background-color: #f4f4f4;
            transition: background-color 0.5s;
        }
    
        .grid-cell.unused {
            background-color: #e0e0e0;
        }
    
        .grid-cell.filled {
            background-color: #add8e6;
        }
    
        .grid-cell.active {
            background-color: #ffcccb;
        }
    </style>
    
    
    <div class="grid-container">
        <!-- Left Section: Form and Buttons -->
        <div class="container">
            <h1>Load/Unload</h1>
            <div class="input-container">
                <label for="offload">Container to Offload:</label>
                <input id="offload" type="text" placeholder="e.g., Cat">
            </div>
            <div class="input-container">
                <label for="load">Container to Load:</label>
                <input id="load" type="text" placeholder="e.g., NewContainer">
            </div>
            <div class="button-container">
                <button class="button" onclick="handleTransfers()">Execute</button>
            </div>
            <div id="result" style="margin-top: 20px;"></div>
            <button id="downloadManifestButton" onclick="triggerManifestDownload()" class="manifest-button">Download Manifest</button>
        </div>
    
        <!-- Right Section: Grid -->
        <div id="animation-grid" class="animation-grid"></div>
    </div>
    
    

    <script>
        let grid = null;
        let filename = "ShipCase";

        function appendToLog(event) {
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 19).replace("T", " ");
            const existingLog = localStorage.getItem("logFileContent") || "";
            const updatedLog = `${existingLog}${timestamp} - ${event}\n`;

            localStorage.setItem("logFileContent", updatedLog);
            console.log(`${timestamp} - ${event}`);
        }

        function parseManifestToGrid(text) {
            const lines = text.trim().split("\n");
            const grid = Array.from({ length: 8 }, () =>
                Array.from({ length: 12 }, () => ({ weight: 0, name: "UNUSED" }))
            );

            lines.forEach(line => {
                const [coordinates, weight, name] = line.split(", ").map(item => item.trim());
                const [row, col] = coordinates.replace("[", "").replace("]", "").split(",").map(Number);
                grid[row - 1][col - 1] = {
                    weight: parseFloat(weight.replace("{", "").replace("}", "")) || 0,
                    name: name,
                };
            });

            return grid;
        }

        function generateManifest(grid) {
            return grid
                .map((row, rowIndex) =>
                    row
                        .map(
                            (cell, colIndex) =>
                                `[${rowIndex + 1},${colIndex + 1}], {${cell.weight}}, ${cell.name}`
                        )
                        .join("\n")
                )
                .join("\n");
        }

        function displayUpdatedManifest(grid) {
    const resultDiv = document.getElementById("result");
    const formattedManifest = generateManifest(grid);

    resultDiv.innerHTML =
        `<h3>Updated Manifest:</h3>
        <pre>${formattedManifest}</pre>`;

    initializeGridDisplay(grid);
}

        async function handleOffload(grid, containerName) {
    const position = findContainer(grid, containerName);
    if (position[0] === -1) {
        alert(`Container "${containerName}" not found.`);
        return;
    }

    const [row, col] = position;
    grid[row][col] = { weight: 0, name: "UNUSED" };

    updateGridCell(row, col, "UNUSED", "offload");
    appendToLog(`Offloaded container "${containerName}" from position [${row + 1}, ${col + 1}]`);
}

async function handleLoad(grid, containerName) {
    const startPosition = [0, 0];
    const availableSlot = aStarFindSlot(grid, startPosition);

    if (availableSlot[0] === -1) {
        alert("No empty slot available for loading.");
        return;
    }

    const [targetRow, targetCol] = availableSlot;
    const weight = Math.floor(Math.random() * 151) + 50;

    grid[targetRow][targetCol] = { weight, name: containerName };

    updateGridCell(targetRow, targetCol, containerName, "load");
    appendToLog(`Loaded container "${containerName}" (weight: ${weight}) into position [${targetRow + 1}, ${targetCol + 1}]`);
}

        async function handleTransfers() {
            const offload = document.getElementById("offload").value.trim();
            const load = document.getElementById("load").value.trim();

            if (!grid) {
                const savedGrid = localStorage.getItem("currentGrid");
                grid = savedGrid ? JSON.parse(savedGrid) : grid;
            }

            if (offload) {
                await handleOffload(grid, offload);
            }

            if (load) {
                await handleLoad(grid, load);
            }

            displayUpdatedManifest(grid);
        }

        function triggerManifestDownload() {
            const manifestContent = generateManifest(grid);
            //const baseName = localStorage.getItem("manifestName")?.split('.')[0] || filename;
            const downloadName = `${filename}OUTBOUND.txt`;

            const blob = new Blob([manifestContent], { type: "text/plain" });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = downloadName;
            link.click();
        }

        window.addEventListener("load", async () => {
    const response = await fetch(`data/${filename}`);
    const manifestText = await response.text();
    grid = parseManifestToGrid(manifestText);
    displayUpdatedManifest(grid);
    initializeGridDisplay(grid);
});

        function findContainer(grid, containerName) {
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[0].length; c++) {
                    if (grid[r][c].name === containerName) {
                        return [r, c];
                    }
                }
            }
            return [-1, -1];
        }

        function isWithinBounds(row, col, grid) {
            return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;
        }

        function aStarFindSlot(grid, start) {
    const directions = [
        [1, 0],  // Down
        [0, 1],  // Right
        [-1, 0], // Up
        [0, -1], // Left
    ];

    const priorityQueue = [{ position: start, cost: 0, heuristic: 0 }];
    const visited = new Set();

    while (priorityQueue.length > 0) {
        // Sort by cost + heuristic (A* priority)
        priorityQueue.sort((a, b) => (a.cost + a.heuristic) - (b.cost + b.heuristic));
        const current = priorityQueue.shift();
        const [currentRow, currentCol] = current.position;

        const currentKey = `${currentRow},${currentCol}`;
        if (visited.has(currentKey)) continue;
        visited.add(currentKey);

        // If a valid slot is found, return it
        if (isValidLoadingSlot(grid, currentRow, currentCol)) {
            return [currentRow, currentCol];
        }

        // Add neighbors to the queue
        for (const [dr, dc] of directions) {
            const neighborRow = currentRow + dr;
            const neighborCol = currentCol + dc;

            if (isWithinBounds(neighborRow, neighborCol, grid) && !visited.has(`${neighborRow},${neighborCol}`)) {
                const heuristic = calculateHeuristic(neighborRow, neighborCol, grid);
                priorityQueue.push({
                    position: [neighborRow, neighborCol],
                    cost: current.cost + 1,
                    heuristic: heuristic,
                });
            }
        }
    }

    return [-1, -1]; // No valid slot found
}

function calculateHeuristic(row, col, grid) {
    // Prioritize column-first, then row order
    return col * 100 + row; // Columns have higher priority
}

function isValidLoadingSlot(grid, row, col) {
    // Slot must be UNUSED and support weight if above row is filled
    if (grid[row][col].name !== "UNUSED") return false;
    if (row === 0) return true; // First row is always valid
    return grid[row - 1][col].name !== "UNUSED"; // Ensure the slot below is filled
}

function isWithinBounds(row, col, grid) {
    return row >= 0 && row < grid.length && col >= 0 && col < grid[0].length;
}

function initializeGridDisplay(grid) {
    const animationGrid = document.getElementById("animation-grid");
    animationGrid.innerHTML = ""; // Clear existing grid

    // Render rows in reverse order for display but keep correct coordinates
    for (let rowIndex = grid.length - 1; rowIndex >= 0; rowIndex--) {
        grid[rowIndex].forEach((cell, colIndex) => {
            const gridCell = document.createElement("div");
            gridCell.classList.add("grid-cell");
            gridCell.classList.add(cell.name === "UNUSED" ? "unused" : "filled");
            gridCell.id = `cell-${grid.length - rowIndex}-${colIndex + 1}`; // Adjust coordinates to start from [1,1]
            gridCell.innerText = cell.name === "UNUSED" ? "" : cell.name;
            animationGrid.appendChild(gridCell);
        });
    }
}




function updateGridCell(row, col, name, action) {
    const cell = document.getElementById(`cell-${row}-${col}`);
    if (!cell) return;

    // Set animation and state
    cell.classList.add("active");
    cell.innerText = name === "UNUSED" ? "" : name;
    cell.classList.remove("filled", "unused");
    cell.classList.add(name === "UNUSED" ? "unused" : "filled");

    setTimeout(() => {
        cell.classList.remove("active");
    }, 500);
}


    </script>
</body>
</html>
